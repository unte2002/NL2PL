# NL2PL (Natural Language to Programming Language) 기획서

> 개발자가 트리를 그리고, LLM이 잎을 채운다.
> 불일치는 표시하되, 해결 시점은 사용자가 결정한다.

---

## 1. 프로젝트 개요

### 배경

LLM의 성능 발전으로 코드 생성 비용이 거의 0에 가까워지면서 바이브코딩이 보편화되고 있다. 그러나 순수 프롬프트 방식의 개발에는 두 가지 핵심 문제가 있다.

첫째, **구현 불일치**: "회계 프로그램 만들어줘"처럼 고수준 프롬프트만으로는 개발자의 의도대로 구현되지 않을 확률이 높다.

둘째, **인지 부채**: 개발자가 프로그램의 내부 구조를 파악하지 못한 채 코드를 사용하게 되어, 디버깅이나 기능 변경/추가 시 오히려 더 많은 시간이 소요된다.

### 핵심 가치 제안

NL2PL은 이 문제를 해결하기 위해 다음의 분업 구조를 제안한다.

- **개발자**: 코드의 전체 구조와 핵심 로직을 자연어 명세로 작성하여 통제권을 유지
- **LLM**: 명세를 기반으로 세부 구현 코드를 생성

이를 통해 개발자는 코드 전체 구조에 대한 장악을 잃지 않으면서 빠르고 저렴한 개발이 가능하다.

### 핵심 원칙

> **추상화 수준의 자율적 조절**: 같은 프로젝트 내에서도 핵심 로직은 정밀하게 명세하고, 보일러플레이트는 한 줄 설명으로 위임하는 것이 자연스럽게 가능해야 한다.

모든 설계 결정은 이 원칙을 지원하는가의 여부로 평가된다.

---

## 2. 타겟 사용자

### 핵심 타겟

**"이해의 깊이를 내가 조절하고 싶은 개발자"**

LLM을 활용하되 블랙박스는 원하지 않고, 그렇다고 전부 손으로 짜기도 비효율적인 사람. 구체적으로는:

- CS 전공 학부/대학원생
- 개인 프로젝트 또는 사이드 프로젝트를 진행하는 주니어 개발자
- 새로운 언어나 프레임워크를 빠르게 익히려는 개발자

### 핵심 페인포인트

```
LLM이 짠 코드는 블랙박스라서 디버깅할 때 내 코드보다 오래 걸린다.
그렇다고 전부 손으로 짜기엔 비효율적이다.
```

### 포지셔닝

```
순수 비개발자 ←————————————————————→ 시니어 개발자
(구조 자체를 모름)                    (굳이 자연어로 쓸 필요 없음)
                    ↑
               NL2PL 타겟
         (구조는 알고 통제하고 싶지만
          자잘한 구현은 맡기고 싶은 개발자)
```

### 기존 도구와의 차별화

| 도구 | 방식 | 한계 |
|------|------|------|
| GitHub Copilot | 로컬 컨텍스트 기반 자동완성 | 구조적 통제 없음 |
| Cursor/Windsurf | 에이전틱 편집 | 블랙박스 문제 동일 |
| Devin | 완전 자율 에이전트 | 개발자 통제권 완전 상실 |
| **NL2PL** | **구조는 개발자, 구현은 LLM** | **개발자 통제권 유지** |

---

## 3. 명세 문법

### 기본 구조

구조 키워드만 최소한으로 고정하고, 나머지는 완전 자유 형식을 허용한다.

**고정 키워드**:
- `입력:` / `출력:` / `동작:`
- `[함수명]` — 의존성 인라인 참조

**자유 요소**:
- 동작 설명의 언어(한국어/영어 혼용 허용)
- 설명의 추상화 수준 (고수준 자연어 ~ 의사코드 ~ 실제 코드 모두 허용)

### 명세 예시

```
function LLM_API_caller
  입력: api_key, prompt, query
  출력: JSON 형식의 답변
  동작:
    1. prompt 끝에 query를 붙여 [OpenAI_call] 호출
    2. 응답을 JSON으로 파싱
    3. 파싱 실패 시 정규표현식 시도, 그래도 실패하면 재호출 최대 1회
    4. 그래도 실패 시 오류 메시지 반환
```

### 설계 원칙

> 도구가 이해해야 하는 부분만 구조화하고, LLM이 이해하면 되는 부분은 자유롭게 둔다.

- `입력/출력/동작` 블록은 도구가 파싱
- `[함수명]` 패턴은 의존 그래프 구성에 사용
- `동작:` 안의 내용은 LLM에게 자연어 그대로 전달

### 명세 파일 포맷

명세는 프로젝트 루트에 **`spec.nl2pl` 단일 파일**로 관리한다.

```
my_project/
  spec.nl2pl       ← 전체 명세 (source of truth)
  src/
    transactions.py
    reports.py
```

단일 파일로 관리하는 이유: 명세를 하나의 설계 문서처럼 전체적으로 탐색할 수 있고, git에서 명세 변경 히스토리가 하나의 파일로 추적된다. 코드 파일과 1:1 대응하는 다중 파일 방식은 IDE 통합이 깊어지는 2차 이후에 검토한다.

### 파서 규칙 (MVP 확정)

자유 형식을 허용하되, 파서가 동작하는 경계 규칙은 명확히 고정한다. **모호한 케이스는 무시**하는 것을 원칙으로 하고, 허용 범위는 나중에 넓힌다.

**블록 경계**: 같은 수준의 다음 키워드(`function`, `module`) 등장 또는 파일 끝에서 현재 블록이 종료된다.

**들여쓰기**: 스페이스와 탭 모두 허용하되, 하나의 파일 안에서 혼용하지 않는다.

**의존성 인식 범위**: `[함수명]` 패턴은 `동작:` 블록 안에서만 의존성으로 인식한다. 일반 설명 텍스트에 등장하는 `[함수명]`은 의존성으로 처리하지 않는다.

**크로스 모듈 참조**: 다른 모듈의 함수를 참조할 때는 `[모듈명.함수명]` 형식을 사용한다.

```
동작:
  1. [거래처리.validate_transaction] 호출   ← 크로스 모듈
  2. [format_output] 호출                   ← 같은 모듈 내
```

같은 모듈 내 참조는 `[함수명]`만으로 충분하다. 이 규칙은 초기에 확정해두지 않으면 나중에 전체 명세를 마이그레이션해야 한다.

---

## 4. 의존성 관리

### 문제

함수 A의 명세가 변경되면, A에 의존하는 함수 B의 생성 코드도 재생성이 필요하다. 이 의존관계를 도구가 어떻게 추적하고 처리할 것인가.

### 의존성 선언 방식: 인라인 참조 (B 방식)

명세의 동작 설명 흐름 안에서 `[함수명]`으로 직접 참조한다.

```
function save_transaction
  입력: transaction 객체
  출력: transaction_id
  동작:
    1. [validate_transaction] 호출, 실패 시 오류 반환
    2. DB에 저장
    3. transaction_id 반환
```

**선택 이유**:
- 명세가 자연스럽게 읽힌다
- `[함수명]` 패턴이 명확해서 파싱이 쉽다
- 강제 선언이 아니어도 됨 — 자연어로 함수명을 언급하면 텍스트 매칭으로 보완 탐지

### 변경 시 처리 흐름

자동 재생성이 아닌 **경고 후 사용자 판단** 방식을 채택한다. 사용자가 B를 직접 수정했을 수 있으므로 자동 덮어쓰기는 하지 않는다.

```
A의 명세 변경 감지 (파일 저장 시점)
        ↓
변경 유형 판단
  ├─ 입력/출력 변경 → 강한 경고 ("재생성 권장")
  └─ 동작 블록만 변경 → 약한 경고 ("검토 권장") 또는 기록만
        ↓
[A에 의존하는 함수 목록] 표시
        ↓
사용자가 재생성 여부 개별 결정
```

**경고 발생 조건**: `입력:`/`출력:` 블록이 변경된 경우에만 강한 경고를 발생시킨다. `동작:` 블록만 변경된 경우는 내부 구현 변경이므로 의존 함수의 인터페이스에 영향이 없어 경고를 최소화한다. 경고가 너무 자주 발생하면 사용자가 무시하는 습관이 생긴다.

**경고 표시 위치**: 사이드 패널에 목록으로 쌓인다. 인라인 팝업은 편집 흐름을 방해하므로 사용하지 않는다. 각 경고는 개별적으로 dismiss 가능하다.

---

## 5. 명세-코드 양방향 관리

### Source of Truth

**명세가 source of truth**다. 코드는 명세로부터 파생되는 산출물이다.

### 코드 수정 발생 시 플로우

```
코드 수정 발생
        ↓
"이 수정사항을 명세에 기록할까요?"
        ↓
기록 안 함                기록함
(그냥 넘어감)                  ↓
                    해당 코드 블록 하이라이트
                    (명세와 불일치 상태 표시)
                           ↓
                    [명세 재생성] 버튼으로
                    언제든 LLM이 명세 갱신 가능
```

### 코드 수정 케이스

| 케이스 | 예시 | 명세 기록 필요성 |
|--------|------|----------------|
| LLM 생성 오류 수정 | 재시도 횟수 3→1 수정 | 높음 |
| 최적화 직접 적용 | O(n²) → set() 방식 | 중간 |
| 변수명 변경 | camelCase → snake_case | 낮음 |
| 명세에 없던 기능 추가 | 트랜잭션 처리 추가 | 높음 |

### 미반영 수정사항 관리

하이라이트된 블록이 쌓일 경우를 대비해 사이드바에 "미반영 수정사항 N개" 뱃지를 표시하여 놓치지 않도록 한다.

---

## 6. 부분-전체 맥락적 관계

### 맥락의 계층

```
프로젝트 레벨: 언어, 프레임워크, 전체 목적, 컨벤션
        ↓
모듈 레벨: 이 모듈의 역할, 모듈 내 다른 함수들
        ↓
함수 레벨: 의존하는 함수들의 명세, 인접 함수들
```

### 코드 생성 시 맥락 전달 전략

**프로젝트 헤더 + 의존 함수 명세** 조합을 사용한다.

```
[프로젝트 헤더] — 항상 포함 (고정, 토큰 부담 낮음)
  언어: Python
  프레임워크: FastAPI
  DB: PostgreSQL
  컨벤션: snake_case, 타입 힌트 필수
  목적: 중소기업용 회계 프로그램

+ [의존 함수 명세] — [함수명] 참조 기반으로 자동 추가
```

**전체 명세를 통째로 넘기지 않는 이유**: 프로젝트 규모가 커질수록 토큰 비용이 폭발적으로 증가하기 때문.

### 상향식 불일치 처리

저수준을 구체화하다가 고수준 명세와 충돌이 발생하는 경우:

```
함수 로직 구체화 중 상위 설계의 오류 발견
        ↓
상위 명세 노드에 불일치 하이라이트 표시
        ↓
사용자가 상위 명세 업데이트 여부 결정
```

---

## 7. 단계적 구체화

### 4단계 구체화

명세는 4단계로 점진적으로 구체화할 수 있다. 코드 생성은 **어느 단계에서나 가능**하며, 명세의 상세함 수준에 비례한 코드가 생성된다.

| 단계 | 내용 | 질문 |
|------|------|------|
| 1. 역할 | 이게 뭘 하는가 | "이 시스템/모듈/함수의 존재 이유는?" |
| 2. 인터페이스 | 어떻게 연결되는가 | "입력과 출력은 무엇인가?" |
| 3. 로직 | 어떻게 동작하는가 | "내부에서 무슨 일이 일어나는가?" |
| 4. 최적화 | 더 잘할 수 있는가 | "성능, 에러 핸들링, 엣지 케이스는?" |

### 단계별 명세 진화 예시

**1단계 — 역할**
```
[프로젝트] 회계 프로그램
  목적: 중소기업 거래 내역 관리 및 리포트 생성
  
  [모듈] 거래 처리 - 거래 입력, 유효성 검사, 저장
  [모듈] 리포트   - 집계, 출력
```

**2단계 — 인터페이스**
```
[모듈] 거래 처리
  [function] validate_transaction
    입력: transaction 객체
    출력: { valid: bool, errors: list }
    
  [function] save_transaction
    입력: transaction 객체
    출력: transaction_id
    의존: [validate_transaction]
```

**3단계 — 로직**
```
[function] save_transaction
  입력: transaction 객체
  출력: transaction_id
  동작:
    1. [validate_transaction] 호출, 실패 시 오류 반환
    2. DB에 저장
    3. transaction_id 반환
```

**4단계 — 최적화**
```
[function] save_transaction
  입력: transaction 객체
  출력: transaction_id
  동작:
    1. [validate_transaction] 호출, 실패 시 오류 반환
    2. DB에 트랜잭션으로 저장 (실패 시 롤백)
    3. 관련 캐시 무효화
    4. transaction_id 반환
```

### 추상화 수준 자율 조절의 실체

```
중요한 함수    → 4단계까지 직접 명세 → 정밀한 코드 생성
덜 중요한 함수 → 2단계만 명세       → 러프한 스캐폴딩 생성
```

---

## 8. 전체 구조 모델

두 계층이 직교하여 개발자가 자유롭게 누빌 수 있는 2D 공간을 형성한다.

```
              역할    인터페이스    로직    최적화
프로젝트   |   ①         ②         ③       ④
모듈       |   ⑤         ⑥         ⑦       ⑧
함수       |   ⑨         ⑩         ⑪       ⑫
```

개발자는 이 표를 자유롭게 이동한다. 전체 역할(①)을 먼저 정의하고, 특정 함수 로직(⑪)으로 바로 내려갈 수도 있다.

**구현 관점 정리**:
- 명세는 트리 구조 (프로젝트 → 모듈 → 함수)
- 각 노드는 4단계로 구체화 가능
- 노드 간 의존성은 `[함수명]`으로 연결
- 코드 생성은 어느 노드, 어느 단계에서나 가능
- 불일치는 하이라이트로 표시, 해결 시점은 사용자가 결정

---

## 9. UI 설계

### 핵심 인터랙션: 접기/펼치기

추상화 수준 자율 조절이 UI 인터랙션으로 구현된다.

```
접힌 상태 = 고수준 명세 (현재 레벨의 요약만 보임)
펼친 상태 = 저수준 명세 (하위 노드가 펼쳐져 보임)
```

**예시**:

접힌 상태:
```
[모듈] 거래 처리 - 거래 입력, 유효성 검사, 저장  ▶
```

펼친 상태 (▶ 클릭 후):
```
[모듈] 거래 처리  ▼
  [function] validate_transaction  ▶
    입력: transaction 객체
    출력: { valid: bool, errors: list }
    
  [function] save_transaction  ▶
    입력: transaction 객체
    출력: transaction_id
    의존: [validate_transaction]
```

### 접힌 요약 자동 갱신

하위 내용이 변경될 때 요약 문구를 즉시 LLM으로 갱신하지 않는다. 속도 문제와 불필요한 API 호출을 방지하기 위해 **명시적 트리거 방식**을 사용한다.

```
[모듈] 거래 처리 - 거래 입력, 유효성 검사, 저장  ↺
```

하위 내용이 바뀌면 요약 옆에 ↺ 아이콘이 표시되고, 사용자가 원할 때 클릭하면 LLM이 요약을 갱신한다.

### MVP UI 요소

| 요소 | 기능 | MVP 포함 |
|------|------|:--------:|
| 접기/펼치기 버튼 | 명세 계층 탐색 | ✅ |
| 함수 명세 편집 폼 | 입력/출력/동작 인라인 편집 | ✅ |
| 코드 생성 버튼 | 선택한 함수의 코드 생성 요청 | ✅ |
| 코드 패널 (Monaco) | 생성된 코드 미리보기 | ✅ |
| 파일 저장 버튼 | 생성된 코드를 지정 경로에 저장 | ✅ |
| 의존성 경고 패널 | 인터페이스 변경 시 영향 함수 목록 표시 | ✅ |
| ↺ 갱신 아이콘 | 접힌 요약을 하위 내용 기반으로 LLM 재생성 | ❌ 2차 |
| 코드 블록 하이라이트 | 명세와 불일치 상태 시각화 | ❌ 2차 |
| 명세 재생성 버튼 | 수정된 코드 기반으로 명세 역방향 업데이트 | ❌ 2차 |
| 의존 그래프 뷰 | 함수 간 의존관계 시각화 | ❌ 2차 |
| 미반영 수정사항 뱃지 | 사이드바에서 불일치 현황 파악 | ❌ 2차 |

### MVP 레이아웃

```
┌──────────────────────┬───────────────────────────┐
│  명세 트리  (좌)     │  코드 패널  (우)           │
│                      │                           │
│  ▼ 거래 처리         │  def validate_transaction │
│    ▶ validate_tr... ●│      ...                  │
│    ▶ save_transa... ⚠│                           │
│                      │  [파일에 저장]  [재생성]   │
│  [+ 모듈 추가]       │                           │
│                      ├───────────────────────────┤
│  ─────────────────   │  ⚠️ 경고 패널              │
│  ⚠️ 경고 1개         │  validate_transaction의   │
│                      │  출력이 변경되었습니다.   │
└──────────────────────┴───────────────────────────┘
```

### 최종 결과물 형태

**1차 MVP: 로컬 웹 서버 (`npx nl2pl`)**

프로젝트 루트에서 `npx nl2pl`을 실행하면 로컬 서버가 뜨고 브라우저에서 위 레이아웃의 웹 앱이 열린다. 설치 없이 실행 가능하고 배포 사이클이 빠르다. 코드 에디터와 창이 분리되는 단점이 있으나, MVP 단계에서는 "에디터 안에 있었으면 좋겠다"는 사용자 반응 자체가 VSCode Extension 개발을 정당화하는 근거가 된다.

**2차: VSCode Extension**

1차에서 만든 React UI를 VSCode Extension의 Webview에 이식한다. React 앱 코드를 그대로 재사용할 수 있어 재작성 비용이 없다. 에디터 통합(코드 파일 직접 열기, 인라인 경고 등)을 이 단계에서 추가한다.

---

## 10. 요약

NL2PL은 자연어 명세와 LLM 코드 생성 사이의 간극을 메우는 도구다. 개발자는 트리 구조의 명세를 작성하고, 원하는 시점에 원하는 깊이로 코드 생성을 위임한다. 명세와 코드 사이의 모든 불일치는 시각적으로 표시되며, 해결 시점은 항상 개발자가 결정한다.

이를 통해 LLM의 코드 생성 속도를 활용하면서도, 개발자가 코드 구조에 대한 이해와 통제권을 잃지 않는 개발 방식을 실현한다.

---

## 11. MVP 범위

### 핵심 가설

> "명세 기반 코드 생성이 순수 프롬프트 방식보다 개발자의 구조적 이해를 실질적으로 높이는가"

이 가설을 가장 빠르게 검증하는 데 집중한다. 전체 기획서의 기능은 가설이 검증된 이후 단계적으로 추가한다.

### MVP 포함 기능

```
✅ 명세 작성 (함수 단위, 입력/출력/동작 블록)
✅ 명세 → 코드 생성 (프로젝트 헤더 + 의존 함수 명세 컨텍스트)
✅ [함수명] 인라인 참조 파싱 및 의존 그래프 구성
✅ 의존 함수 명세 변경 시 영향 함수 목록 경고
```

### MVP 제외 기능 (2차 이후)

```
❌ 코드 → 명세 역방향 갱신
❌ 명세-코드 불일치 하이라이트 (자동 감지)
❌ 미반영 수정사항 뱃지
❌ 접힌 요약 LLM 재생성 (↺ 아이콘)
❌ 의존 그래프 시각화 뷰
```

### MVP 성공 기준

- 동일 기능을 순수 프롬프트로 짠 코드 대비, NL2PL 명세 기반 코드의 구조 파악 속도 개선 여부
- 실제 사용자가 명세 작성 후 생성된 코드를 "자기 코드처럼 느끼는가" (정성 인터뷰)

---

## 12. 설계 보완 사항

*기획서 검토 과정에서 도출된 구체적 설계 이슈들. 각 항목은 MVP 이후 단계에서 구현 시 반드시 반영한다.*

### 의존성 전파의 세분화

현재 의존성 경고는 "A의 명세가 바뀌면 B에 경고"처럼 단순 참조 기반이다. 그러나 변경의 종류에 따라 전파 강도가 달라야 한다.

| 변경 유형 | 예시 | 전파 강도 |
|-----------|------|-----------|
| 인터페이스 변경 | 입력 파라미터 추가/삭제, 반환 타입 변경 | 강 — 의존 함수 코드 재생성 필요 |
| 로직 변경 | 내부 동작 방식 변경, 사이드 이펙트 추가 | 중 — 의존 함수 검토 권장 |
| 최적화 변경 | 성능 개선, 내부 구현 교체 (인터페이스 불변) | 약 — 경고 없이 기록만 |

구현 방향: 의존성 경고 발생 시 "인터페이스가 변경되었습니다 (재생성 권장)" vs "로직이 변경되었습니다 (검토 권장)"처럼 메시지를 구분하여 표시한다.

### 역방향 명세 갱신 시 단계 잠금

코드 수정 후 [명세 재생성] 기능을 사용할 때, LLM이 개발자가 직접 작성한 역할(1단계)·인터페이스(2단계) 명세를 덮어쓸 위험이 있다.

```
역방향 갱신 대상:
  🔒 1단계 (역할)      — 잠금. LLM이 수정 불가
  🔒 2단계 (인터페이스) — 잠금. 단, 실제 코드와 시그니처가 다르면 경고만 표시
  ✏️  3단계 (로직)      — 갱신 대상. LLM이 코드 diff 분석 후 초안 제안
  ✏️  4단계 (최적화)    — 갱신 대상. LLM이 코드 diff 분석 후 초안 제안
```

LLM이 생성한 명세 초안은 "제안" 상태로 표시되며, 개발자가 확인·편집 후 확정한다. 자동 덮어쓰기는 하지 않는다.

### 정합성 판단의 기술적 구체화

"명세와 코드의 불일치"를 감지하는 방식이 현재 명시되어 있지 않다. 텍스트 단순 비교는 오탐이 많아 신뢰도가 낮다.

구현 전략:
- **인터페이스 정합성**: AST 파싱으로 실제 함수 시그니처(파라미터명, 타입, 반환 타입)를 추출하여 명세의 `입력/출력` 블록과 비교. 불일치 시 하이라이트.
- **로직 정합성**: 코드 변경 diff를 LLM에 전달하여 "명세에 기술된 동작과 일치하는가"를 판단. 완전 자동화보다는 저장 시점에 사용자가 확인하는 반자동 방식.
- **감지 트리거**: 매 타이핑이 아닌 **파일 저장 시점**에만 diff 비교를 실행하여 노이즈를 줄인다.

### 타입·스키마 컨텍스트 레이어

코드 생성 시 프로젝트 헤더와 의존 함수 명세만 전달하면, LLM이 DTO나 DB 스키마를 잘못 추정하여 인터페이스 불일치 코드를 생성하는 문제가 발생할 수 있다.

```
[프로젝트 헤더]
  ...

+ [타입/스키마 정의] — 선택적으로 작성, 코드 생성 시 자동 포함
  transaction: { id, amount, date, account_id, type }
  account: { id, name, balance }

+ [의존 함수 명세]
  ...
```

타입/스키마 레이어는 별도 섹션으로 명세 트리에 추가하며, 함수 명세에서 `transaction 객체`처럼 타입명을 참조하면 해당 정의가 생성 컨텍스트에 자동으로 포함된다.

### 전역 맥락 주입 (Context Manager)

환경 변수, 설정 파일, 전역 상태처럼 코드 실행에 영향을 주지만 특정 함수 명세에 귀속되지 않는 정보를 LLM에 전달하는 전략이 필요하다.

```
[프로젝트 헤더] 확장:
  언어: Python
  프레임워크: FastAPI
  DB: PostgreSQL
  컨벤션: snake_case, 타입 힌트 필수
  목적: 중소기업용 회계 프로그램
  환경: .env에서 DB_URL, SECRET_KEY 로드
  전역 상태: 없음 (stateless API)
  외부 의존성: sqlalchemy 2.x, pydantic v2
```

프로젝트 헤더에 `환경`, `전역 상태`, `외부 의존성` 필드를 선택적으로 추가할 수 있도록 하고, 이 정보는 모든 코드 생성 요청에 포함된다. 이를 통해 deprecated API 사용이나 전역 상태 충돌 문제를 사전에 줄인다.

---

## 13. 기술 스택 (MVP)

### 전체 구조

```
nl2pl/
├── packages/
│   ├── shared/     ← 서버·클라이언트 공유 TypeScript 타입
│   ├── server/     ← Node.js (Express + WebSocket)
│   └── client/     ← React (Vite)
└── package.json    ← npm workspace
```

`npx nl2pl` 실행 시 서버가 뜨고, 빌드된 React 앱을 서버가 정적 파일로 서빙한다. 단일 프로세스, 단일 포트.

### 스택 선택

| 영역 | 선택 | 이유 |
|------|------|------|
| 서버 | Express + TypeScript | 단순함, 레퍼런스 풍부 |
| 클라이언트 | React + Vite | 상태 관리 자연스러움, 빌드 빠름 |
| 코드 패널 | Monaco Editor | VSCode와 동일한 편집 경험 |
| 실시간 통신 | WebSocket (ws) | 양방향 메시지 + LLM 스트리밍 |
| 상태 관리 | Zustand | 경량, 보일러플레이트 없음 |
| 스타일링 | Tailwind CSS | 밀도 높은 레이아웃 직접 제어 |
| LLM | OpenAI SDK | MVP 단일 모델 고정 |
| 파일 감지 | chokidar | Node.js 파일 감지 표준 |

**실시간 통신으로 WebSocket을 선택한 이유**: LLM 응답 스트리밍(서버→클라이언트)과 경고 dismiss(클라이언트→서버)를 하나의 채널로 처리할 수 있다. SSE는 단방향이라 추가 HTTP 요청이 필요해 복잡해진다.

### 핵심 자료구조

서버와 클라이언트가 공유하는 타입을 `packages/shared`에 먼저 확정한다. 이 타입이 파서, 프롬프트 조립, UI 컴포넌트를 일관되게 연결하는 뼈대다.

```typescript
type NodeStatus = 'empty' | 'generated' | 'stale'
// empty:     코드 생성 전
// generated: 코드 생성 완료, 파일에 저장됨
// stale:     의존 함수 인터페이스 변경으로 재생성 권장

interface FunctionSpec {
  id: string
  name: string
  inputs: string        // 원문 그대로 보존
  outputs: string       // 원문 그대로 보존
  behavior: string      // 원문 그대로 보존, LLM에 그대로 전달
  dependencies: string[] // [함수명] 또는 [모듈명.함수명] 파싱 결과
  outputPath?: string   // 저장된 파일 경로
  status: NodeStatus
}

interface ModuleSpec {
  id: string
  name: string
  functions: FunctionSpec[]
}

interface ProjectSpec {
  language: string
  framework: string
  db?: string
  conventions: string
  purpose: string
  environment?: string     // 환경변수 등 전역 맥락
  globalState?: string     // 전역 상태
  externalDeps?: string    // 외부 의존성 버전
  modules: ModuleSpec[]
}

// WebSocket 메시지 타입
type ServerMessage =
  | { type: 'spec_updated'; spec: ProjectSpec }
  | { type: 'dependency_warning'; affected: string[]; changedFunction: string; changeType: 'interface' | 'behavior' }
  | { type: 'generation_chunk'; functionId: string; chunk: string }
  | { type: 'generation_done'; functionId: string }

type ClientMessage =
  | { type: 'generate'; functionId: string }
  | { type: 'save_file'; functionId: string; path: string; code: string }
  | { type: 'dismiss_warning'; functionId: string }
```

---

## 14. MVP 사용자 시나리오

*회계 프로그램 예시를 기준으로 한 구체적인 사용 흐름.*

### 시작

```bash
$ cd my_accounting_project
$ npx nl2pl
→ http://localhost:3000
```

### 1단계: 프로젝트 헤더 설정

첫 실행 시 프로젝트 헤더 입력 폼이 표시된다. 언어, 프레임워크, 컨벤션, 목적을 입력하면 `spec.nl2pl`이 생성된다. 이후 실행 시에는 이 화면을 건너뛴다.

### 2단계: 명세 작성

모듈을 추가하고 그 안에 함수를 추가한다. 함수 카드를 클릭하면 입력/출력/동작 편집 폼이 인라인으로 열린다. 저장은 자동이며, 입력 내용이 실시간으로 `spec.nl2pl`에 반영된다.

`동작:` 블록에 `[validate_transaction]`을 입력하는 순간 툴팁이 표시되고, 저장 후 트리에 의존 관계가 시각화된다.

### 3단계: 코드 생성

함수 카드의 "코드 생성" 버튼을 클릭하면 오른쪽 코드 패널에 스트리밍으로 코드가 나타난다. 생성이 완료되면 트리의 해당 함수에 ● 표시가 생긴다.

### 4단계: 파일 저장

"파일에 저장"을 클릭하면 저장 경로 입력창이 뜬다. "이 경로를 기억하기"를 체크하면 이후 같은 버튼 클릭 시 바로 덮어쓴다.

MVP에서는 함수 단위가 아닌 **파일 전체를 덮어쓰는** 방식으로 단순화한다. 함수 단위 교체(기존 파일에 특정 함수만 삽입/수정)는 2차에서 구현한다.

### 5단계: 의존성 경고

`validate_transaction`의 `출력:` 블록을 수정하고 저장하면, 즉시 경고 패널이 활성화된다.

```
⚠️ 인터페이스 변경 감지
validate_transaction의 출력이 변경되었습니다.

영향받는 함수:
• save_transaction (재생성 권장)

[무시]  [save_transaction 재생성]
```

"재생성"을 클릭하면 해당 함수의 코드 패널로 포커스가 이동하며 코드가 바로 재생성된다.

### 최종 파일 구조

```
my_accounting_project/
  spec.nl2pl              ← 명세 (source of truth)
  src/
    transactions.py       ← LLM 생성 코드
    reports.py            ← LLM 생성 코드
```

---

## 15. 구현 계획

### 구현 순서와 이유

파서가 모든 것의 기반이다. 파서가 불안정하면 의존 그래프, LLM 프롬프트, UI 모두 흔들린다. 파서를 먼저 완성하고 단위 테스트로 안정화한 뒤 위로 쌓는다.

```
1단계 (3~4일): 파서 + 의존 그래프
  spec.nl2pl 문자열 → ProjectSpec 객체
  ProjectSpec → 역방향 의존 맵 { 'A': ['B', 'C'] }
  두 ProjectSpec 비교 → 변경된 필드 (interface / behavior)
  → 이 레이어는 순수 함수라 단위 테스트가 쉽다

2단계 (2~3일): LLM 파이프라인
  UI 없이 스크립트로 먼저 검증
  프롬프트 조립 → OpenAI 호출 → 결과 파일 저장
  → 프롬프트 품질을 이 단계에서 충분히 다듬는다

3단계 (2~3일): 서버 + WebSocket
  Express 서버, chokidar 파일 감지, WebSocket 채널 연결
  → wscat으로 메시지 송수신 확인 후 다음 단계로

4단계 (5~7일): React UI
  Zustand 스토어 → SpecPanel → CodePanel → 경고 패널
  컴포넌트를 독립적으로 개발하고 WebSocket은 마지막에 연결

5단계 (2~3일): 통합 + 버그 수정
  전체 시나리오 흐름 점검, 엣지 케이스 처리
```

### 총 예상 기간

| 단계 | 기간 |
|------|------|
| 파서 + 의존 그래프 | 3~4일 |
| LLM 파이프라인 | 2~3일 |
| 서버 + WebSocket | 2~3일 |
| React UI | 5~7일 |
| 통합 + 버그 수정 | 2~3일 |
| **합계** | **약 2~3주** |

### 시작점

가장 먼저 할 일은 `spec.nl2pl` 파서의 입력과 출력을 TypeScript 타입으로 확정하고, 다양한 케이스(의존성 있음/없음, 크로스 모듈 참조, 존재하지 않는 함수 참조, 동작 블록 없음)에 대한 테스트를 먼저 작성하는 것이다. 테스트가 통과하는 파서를 완성하면 나머지는 그 위에 자연스럽게 쌓인다.