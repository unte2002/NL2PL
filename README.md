# NL2PL

> 개발자가 트리를 그리고, LLM이 잎을 채운다.

자연어 명세(Natural Language Spec)를 기반으로 LLM이 코드를 생성하는 로컬 개발 도구입니다. 개발자는 코드의 **구조와 핵심 로직**을 명세로 작성하고, **세부 구현**은 LLM에 위임합니다.

---

## 왜 NL2PL인가

순수 프롬프트 방식의 AI 코드 생성에는 두 가지 문제가 있습니다.

- **구현 불일치**: 고수준 프롬프트만으로는 개발자의 의도대로 구현될 확률이 낮습니다.
- **인지 부채**: LLM이 생성한 코드의 내부 구조를 파악하지 못해, 이후 디버깅과 기능 변경에 오히려 더 많은 시간이 걸립니다.

NL2PL은 이 문제를 **분업 구조**로 해결합니다.

| 역할 | 담당 |
|------|------|
| 코드 전체 구조와 핵심 로직 | 개발자 (자연어 명세) |
| 세부 구현 코드 생성 | LLM |

---

## 빠른 시작

```bash
cd my_project
npx nl2pl
# → http://localhost:3000
```

설치 없이 프로젝트 루트에서 실행하면 브라우저에서 바로 사용할 수 있습니다.

---

## 명세 작성 방법

명세는 프로젝트 루트의 `spec.nl2pl` 단일 파일로 관리됩니다.

### 기본 구조

```
function 함수명
  입력: 파라미터 설명
  출력: 반환값 설명
  동작:
    1. 수행할 작업
    2. [다른_함수] 참조 시 인라인으로 표기
```

- `입력:` / `출력:` / `동작:` 블록은 도구가 파싱합니다.
- `[함수명]` 패턴은 **의존성**으로 인식되어 의존 그래프를 자동으로 구성합니다.
- `동작:` 안의 설명은 LLM에 자연어 그대로 전달됩니다.

### 명세 예시

```
function validate_transaction
  입력: transaction 객체
  출력: { valid: bool, errors: list }
  동작:
    1. amount가 0보다 큰지 확인
    2. account_id가 존재하는지 DB 조회
    3. date 형식이 ISO 8601인지 검증

function save_transaction
  입력: transaction 객체
  출력: transaction_id
  동작:
    1. [validate_transaction] 호출, 실패 시 오류 반환
    2. DB에 트랜잭션으로 저장 (실패 시 롤백)
    3. transaction_id 반환
```

### 추상화 수준은 자유롭게

같은 프로젝트 안에서도 핵심 로직은 정밀하게, 보일러플레이트는 한 줄로 위임할 수 있습니다.

```
function generate_report
  입력: date_range
  출력: PDF 파일
  동작: 거래 내역을 집계하여 PDF 리포트 생성
```

---

## 주요 기능

### 명세 트리 탐색

모듈 → 함수 계층 구조를 접기/펼치기로 탐색합니다. 큰 프로젝트에서도 전체 구조를 한눈에 파악할 수 있습니다.

```
▼ 거래 처리
  ▶ validate_transaction  ●
  ▶ save_transaction      ⚠
```

- `●` 코드 생성 완료
- `⚠` 의존 함수 변경으로 재생성 권장

### 코드 생성

함수 카드에서 "코드 생성" 버튼을 클릭하면 오른쪽 패널에 코드가 스트리밍됩니다. 프로젝트 헤더(언어, 프레임워크, 컨벤션)와 의존 함수 명세가 자동으로 컨텍스트에 포함됩니다.

### 의존성 경고

`validate_transaction`의 `출력:` 블록을 수정하면, 이를 참조하는 함수 목록이 즉시 경고 패널에 표시됩니다.

```
⚠️ 인터페이스 변경 감지
validate_transaction의 출력이 변경되었습니다.

영향받는 함수:
• save_transaction (재생성 권장)

[무시]  [save_transaction 재생성]
```

자동 재생성이 아닌 **경고 후 사용자 판단** 방식입니다. 개발자가 직접 수정한 코드를 도구가 덮어쓰지 않습니다.

---

## UI 레이아웃

```
┌──────────────────────┬───────────────────────────┐
│  명세 트리  (좌)     │  코드 패널  (우)           │
│                      │                           │
│  ▼ 거래 처리         │  def validate_transaction │
│    ▶ validate_tr... ●│      ...                  │
│    ▶ save_transa... ⚠│                           │
│                      │  [파일에 저장]  [재생성]   │
│  [+ 모듈 추가]       │                           │
│                      ├───────────────────────────┤
│  ─────────────────   │  ⚠️ 경고 패널              │
│  ⚠️ 경고 1개         │  validate_transaction의   │
│                      │  출력이 변경되었습니다.   │
└──────────────────────┴───────────────────────────┘
```

---

## 프로젝트 구조

```
my_project/
  spec.nl2pl        ← 전체 명세 (source of truth)
  src/
    transactions.py ← LLM 생성 코드
    reports.py      ← LLM 생성 코드
```

---

## 기존 도구와의 비교

| 도구 | 방식 | 한계 |
|------|------|------|
| GitHub Copilot | 로컬 컨텍스트 기반 자동완성 | 구조적 통제 없음 |
| Cursor / Windsurf | 에이전틱 편집 | 블랙박스 문제 동일 |
| Devin | 완전 자율 에이전트 | 개발자 통제권 완전 상실 |
| **NL2PL** | **구조는 개발자, 구현은 LLM** | **개발자 통제권 유지** |

---

## 기술 스택

| 영역 | 기술 |
|------|------|
| 서버 | Express + TypeScript |
| 클라이언트 | React + Vite |
| 코드 패널 | Monaco Editor |
| 실시간 통신 | WebSocket |
| 상태 관리 | Zustand |
| 스타일링 | Tailwind CSS |
| LLM | OpenAI API |
| 파일 감지 | chokidar |

---

## 타겟 사용자

LLM을 활용하되 블랙박스는 원하지 않고, 그렇다고 전부 손으로 짜기도 비효율적인 개발자.

- CS 전공 학부/대학원생
- 개인·사이드 프로젝트를 진행하는 주니어 개발자
- 새로운 언어나 프레임워크를 빠르게 익히려는 개발자

---

## 로드맵

**MVP (현재)**
- 함수 단위 명세 작성 (입력/출력/동작 블록)
- 명세 기반 코드 생성
- 인라인 `[함수명]` 의존성 파싱 및 의존 그래프 구성
- 의존 함수 인터페이스 변경 시 영향 함수 목록 경고

**2차**
- 코드 → 명세 역방향 갱신
- 명세-코드 불일치 하이라이트 자동 감지
- 의존 그래프 시각화
- VSCode Extension

---

## 라이선스

MIT
